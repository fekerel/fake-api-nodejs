// @ts-check
import fs from 'fs';
import path from 'path';
import { fileURLToPath, pathToFileURL } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const root = path.resolve(__dirname, '..');

const entitiesPath = path.join(root, 'schema', 'entities.mjs');
const outDir = path.join(root, 'types');
const outFile = path.join(outDir, 'schema-types.d.ts');

const mod = await import(pathToFileURL(entitiesPath).href);
const entitySchemas = mod.entitySchemas || {};

/**
 * @typedef {'string'|'integer'|'number'|'boolean'|'enum'|'timestamp'} FlatType
 */

/**
 * @param {Record<string, any>} schema
 * @param {string} [prefix]
 * @returns {{path:string, type:FlatType}[]}
 */
function flattenEntityFields(schema, prefix = '') {
  /** @type {{path:string, type:FlatType}[]} */
  const out = [];
  for (const [k, spec] of Object.entries(schema || {})) {
    const name = prefix ? `${prefix}.${k}` : k;
    if (!spec) continue;
    if (spec.type === 'object' && spec.fields) {
      out.push(...flattenEntityFields(spec.fields, name));
      continue;
    }
    if (spec.type === 'array') continue; // array sorgulama için atla

    /** @type {FlatType} */
    let t = /** @type {FlatType} */ (spec.type || 'string');
    if (spec.type === 'enum') t = 'enum';
    if (spec.type === 'timestamp') t = 'timestamp';
    if (spec.type === 'integer') t = 'integer';
    if (spec.type === 'number') t = 'number';
    if (spec.type === 'boolean') t = 'boolean';
    if (spec.primary && !spec.type) t = 'integer';

    out.push({ path: name, type: t });
  }
  return out;
}

/** @type {Record<string, Record<string, FlatType>>} */
const fieldPathMap = {};
for (const [entity, schema] of Object.entries(entitySchemas)) {
  fieldPathMap[entity] = flattenEntityFields(schema).reduce((acc, f) => {
    acc[f.path] = f.type;
    return acc;
  }, /** @type {Record<string, FlatType>} */ ({}));
}

/**
 * @param {string[]} arr
 */
function toLiteralStringUnion(arr) {
  return arr.map((s) => `'${String(s).replace(/'/g, "\\'")}'`).join(' | ') || 'never';
}

const entities = Object.keys(fieldPathMap);
const header = `// AUTO-GENERATED by tools/generate-schema-types.mjs — DO NOT EDIT
// Edit schema/entities.mjs and re-run: npm run types:gen

type QueryOp = 'eq' | 'like' | 'gte' | 'lte';
type FieldType = 'string' | 'integer' | 'number' | 'boolean' | 'enum' | 'timestamp';

type AllowedOpsFor<T extends FieldType> =
  T extends 'string' ? ('eq' | 'like') :
  T extends 'enum' ? 'eq' :
  T extends 'integer' | 'number' | 'timestamp' ? ('eq' | 'gte' | 'lte') :
  T extends 'boolean' ? 'eq' :
  never;

interface FieldPathMap {
${entities.map(e => {
  const entries = Object.entries(fieldPathMap[e]);
  const body = entries.length
    ? entries.map(([p, t]) => `    '${p}': '${t}';`).join('\n')
    : '';
  return `  ${e}: {\n${body}\n  };`;
}).join('\n')}
}

type FilterConfig = {
  [E in keyof FieldPathMap]?: {
    [P in keyof FieldPathMap[E]]?: AllowedOpsFor<FieldPathMap[E][P]>[]
  }
};
`;

if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
fs.writeFileSync(outFile, header, 'utf8');
console.log(`Generated ${path.relative(root, outFile)}`);
